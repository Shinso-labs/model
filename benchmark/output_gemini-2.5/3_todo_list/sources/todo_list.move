module todo_list::todo_list {
    use sui::object::{Self, UID, ID};
    use sui::transfer;
    use sui::tx_context::{Self, TxContext};
    use sui::event;
    use sui::vec;

    /// Error codes for the TodoList module.
    const EIndexOutOfBounds: u64 = 0; // Corresponds to "Index out of bounds" in Solidity

    /// Represents a single TodoList object.
    /// Each TodoList is an independent object owned by an address.
    public struct TodoList has key, store {
        id: UID,
        owner: address,
        items: vector<vector<u8>>, // Stores todo items as a vector of strings (vector<u8>)
    }

    // == Event Definitions ==
    /// Event emitted when a new TodoList is created.
    public struct ListCreatedEvent has Copy, Drop {
        list_id: ID,
        owner: address,
    }

    /// Event emitted when an item is added to a TodoList.
    public struct ItemAddedEvent has Copy, Drop {
        list_id: ID,
        item: vector<u8>,
    }

    /// Event emitted when an item is removed from a TodoList.
    public struct ItemRemovedEvent has Copy, Drop {
        list_id: ID,
        index: u64,
        item: vector<u8>,
    }

    /// Event emitted when a TodoList is deleted.
    public struct ListDeletedEvent has Copy, Drop {
        list_id: ID,
        owner: address,
    }

    /// Module initializer.
    /// This function runs once when the module is published.
    fun init(ctx: &mut TxContext) {
        // In Solidity, the constructor initialized `nextId`.
        // In Move, `UID`s are generated by the system, so no global counter is needed.
        // No shared objects or global state to initialize here.
    }

    // == Entry Functions (External API) ==

    /// Create a new todo list.
    /// This function creates a new `TodoList` object and transfers ownership to the sender.
    public entry fun new_list(ctx: &mut TxContext) {
        let sender = tx_context::sender(ctx);
        let list = TodoList {
            id: object::new(ctx),
            owner: sender,
            items: vec::empty(),
        };
        let list_id = object::id(&list);

        // Transfer the newly created TodoList object to the sender.
        // This makes the sender the owner of this specific TodoList object.
        transfer::transfer(list, sender);

        event::emit(ListCreatedEvent {
            list_id: list_id,
            owner: sender,
        });
    }

    /// Add a new todo item to a specific list.
    /// Only the owner of the `TodoList` object can call this function with a mutable reference.
    public entry fun add_item(list: &mut TodoList, item: vector<u8>) {
        // The ownership check (`_requireOwner` in Solidity) is implicitly handled by Move's type system.
        // Only the current owner of the `TodoList` object can pass a mutable reference (`&mut TodoList`)
        // to an entry function in a transaction.
        vec::push_back(&mut list.items, item);

        event::emit(ItemAddedEvent {
            list_id: object::id(list),
            item: item,
        });
    }

    /// Remove an item by index from a specific list.
    /// Only the owner of the `TodoList` object can call this function.
    public entry fun remove_item(list: &mut TodoList, index: u64) {
        // Check for index out of bounds, similar to Solidity's `require`.
        assert!(index < vec::length(&list.items), EIndexOutOfBounds);

        // `vec::swap_remove` is an efficient way to remove an element by index
        // by swapping it with the last element and then popping.
        let removed_item = vec::swap_remove(&mut list.items, index);

        event::emit(ItemRemovedEvent {
            list_id: object::id(list),
            index: index,
            item: removed_item,
        });
    }

    /// Delete an entire list.
    /// This function takes the `TodoList` object by value, consuming it and effectively deleting it from storage.
    /// Only the owner of the `TodoList` object can pass it by value in a transaction.
    public entry fun delete_list(list: TodoList) {
        // The ownership check is implicit. When an object is passed by value to an entry function,
        // the transaction must be signed by the object's owner.
        let TodoList { id, owner, items } = list;

        // Destroy the vector of items. `vec::destroy_empty` ensures it's empty before destruction.
        // If items were resources, they would need to be explicitly handled or transferred.
        vec::destroy_empty(items);

        // Delete the object's UID, marking it as deleted on-chain.
        object::delete(id);

        event::emit(ListDeletedEvent {
            list_id: id,
            owner: owner,
        });
    }

    // == Public View Functions ==

    /// Get the number of items in a list.
    public fun length(list: &TodoList): u64 {
        vec::length(&list.items)
    }

    /// View a specific item by index.
    public fun get_item(list: &TodoList, index: u64): vector<u8> {
        // Check for index out of bounds.
        assert!(index < vec::length(&list.items), EIndexOutOfBounds);
        // Return a copy of the item at the given index.
        *vec::borrow(&list.items, index)
    }

    // The Solidity function `getListsOf(address user)` is not directly translated to an on-chain Move function.
    // In Sui, querying all objects of a certain type owned by a specific address is typically
    // handled by off-chain indexers (e.g., the Sui Explorer or a custom GraphQL/RPC query).
    // Maintaining such a global mapping on-chain would introduce a bottleneck for parallel execution.
}